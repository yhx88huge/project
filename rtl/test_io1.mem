/// Verilog Memory Initialization File (.mem) generated by ./ex3_asm

/// 12-bit address
/// 16-bit data

// interrupt entry point
@000 0000	///  ST0: 0000 [0000]: (    0:    0)      	// interrupt return address
@001 4024	///       0001 [4024]: BUN 024   (I_HND)	// goto I_HND (interrupt handler)
// program entry point
// initialize data
@010 7800	///  INI: 0010 [7800]: CLA              	// AC <- 0
@011 3042	///       0011 [3042]: STA 042   (  STT)	// M[STT] <- 0
@012 3043	///       0012 [3043]: STA 043   (  SFG)	// M[SFG] <- 0
// IMSK[3:0] : { S_IN, S_OUT, P_IN, P_OUT }
@013 2045	///       0013 [2045]: LDA 045   (  VH8)	// AC <- M[VH8] (1000)
@014 f008	///       0014 [f008]: IMK              	// IMSK <- (1000) (S_IN enabled)
@015 f020	///       0015 [f020]: SIO              	// IOT <- 1 (serial-IO selected)
@016 f080	///       0016 [f080]: ION              	// enable interrupt
@017 2042	///   L0: 0017 [2042]: LDA 042   (  STT)	// AC <- M[STT]
@018 7008	///       0018 [7008]: SNA              	// (M[STT] < 0) ? skip next
@019 4017	///       0019 [4017]: BUN 017   (   L0)
@01a 7001	///       001a [7001]: HLT              
//////////// subroutine (check end-character) ////////
@01b 0000	///  CEC: 001b [0000]: (    0:    0)      
// arg0 (AC) : output character
// end-character = 0x4 (ctrl-D)
@01c 1047	///       001c [1047]: ADD 047   (  VM4)	// AC <- AC - 4
@01d 7004	///       001d [7004]: SZA              	// (AC == 0) ? skip next
@01e c01b	///       001e [c01b]: BUN 01b I (  CEC)	// return from CEC
// output character matches (ctrl-D)
@01f 2046	///       001f [2046]: LDA 046   (  VM1)	// AC <- -1
@020 3042	///       0020 [3042]: STA 042   (  STT)	// M[STT] <- -1
@021 7800	///       0021 [7800]: CLA              	// AC <- 0
@022 f008	///       0022 [f008]: IMK              	// IMSK <- 0 (all interrupts disabled)
@023 c01b	///       0023 [c01b]: BUN 01b I (  CEC)	// return from CEC
//////////// interrupt handler /////////
// 1. store AC & E to memory
@024 303f	///I_HND: 0024 [303f]: STA 03f   (   BA)	// M[BA] <- AC	(store AC)
@025 7040	///       0025 [7040]: CIL              	// AC[0] <- E	(AC[15:1] is not important here...)
@026 3040	///       0026 [3040]: STA 040   (   BE)	// M[BE] <- AC	(store E)
// 2. check SFG and S_IN
@027 2043	///  SIN: 0027 [2043]: LDA 043   (  SFG)	// AC <- M[SFG]
@028 7004	///       0028 [7004]: SZA              	// (M[SFG] == 0) ? skip next
@029 4031	///       0029 [4031]: BUN 031   (  SOU)	// goto SOU
@02a f200	///       002a [f200]: SKI              	// (S_IN ready) ? skip next
@02b 403a	///       002b [403a]: BUN 03a   (  IRT)	// goto IRT
// S_IN is ready --> update IMSK (disable S_IN, enable S_OUT)
@02c 2044	///       002c [2044]: LDA 044   (  VH4)	// AC   <- (0100)
@02d f008	///       002d [f008]: IMK              	// IMSK <- (0100) (enable S_OUT)
// read S_IN data
@02e f800	///       002e [f800]: INP              	// AC(7:0) <- INPR
@02f 3041	///       002f [3041]: STA 041   (  SDT)	// M[SDT] <- AC
@030 6043	///       0030 [6043]: ISZ 043   (  SFG)	// ++M[SFG]
// 3. check GP_OUT
// M[SFG] != 0
@031 f100	///  SOU: 0031 [f100]: SKO              	// (S_OUT ready) ? skip next
@032 403a	///       0032 [403a]: BUN 03a   (  IRT)	// goto IRT
// S_OUT is ready --> update IMSK (disable S_OUT, enable S_IN)
@033 2045	///       0033 [2045]: LDA 045   (  VH8)	// AC   <- (1000) 
@034 f008	///       0034 [f008]: IMK              	// IMSK <- (1000) (enable S_IN)
// output to S_OUT
@035 2041	///       0035 [2041]: LDA 041   (  SDT)	// AC <- M[SDT]
@036 f400	///       0036 [f400]: OUT              	// OUTR <- AC
@037 501b	///       0037 [501b]: BSA 01b   (  CEC)	// call CEC (check end-character)
@038 7800	///       0038 [7800]: CLA              	// AC <- 0
@039 3043	///       0039 [3043]: STA 043   (  SFG)	// M[SFG] <- 0
// 4. restore AC & E from memory
@03a 2040	///  IRT: 003a [2040]: LDA 040   (   BE)	// AC <- M[BE]
@03b 7080	///       003b [7080]: CIR              	// E <- AC[0]	(restore E)
@03c 203f	///       003c [203f]: LDA 03f   (   BA)	// AC <- M[BA]	(restore AC)
@03d f080	///       003d [f080]: ION              	// IEN <- 1		(enable interrupt)
@03e c000	///       003e [c000]: BUN 000 I (  ST0)	// indirect return (return address stored in ST0)
// data (no initialization)
@03f 0000	///   BA: 003f [0000]: (    0:    0)      	// backup storage for AC during interrupt handling
@040 0000	///   BE: 0040 [0000]: (    0:    0)      	// backup storage for  E during interrupt handling
@041 0000	///  SDT: 0041 [0000]: (    0:    0)      	// S_IN data
// data (need initialization code)
@042 0000	///  STT: 0042 [0000]: (    0:    0)      	// state
@043 0000	///  SFG: 0043 [0000]: (    0:    0)      	// S_IN flag
// data (read-only)
@044 0004	///  VH4: 0044 [0004]: (    4:    4)      	// VH4 = 0x4 (0100)
@045 0008	///  VH8: 0045 [0008]: (    8:    8)      	// VHA = 0x8 (1000)
@046 ffff	///  VM1: 0046 [ffff]: (   -1:65535)      	// VM1 = -1
@047 fffc	///  VM4: 0047 [fffc]: (   -4:65532)      	// VM4 = -4
